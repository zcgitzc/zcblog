<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Your Blog</title>
    <description></description>
    <link>http://localhost:4000/Jlcaoblog-boilerplate/</link>
    <atom:link href="http://localhost:4000/Jlcaoblog-boilerplate/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 02 Sep 2019 00:27:57 +0800</pubDate>
    <lastBuildDate>Mon, 02 Sep 2019 00:27:57 +0800</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>在Github Pages上部署简历</title>
        <description>&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;
&lt;p&gt;每年的金三银四都是人员流动最大，找工作最好的时间段之一。而找工作就不得不需要更新简历，想到自己也会有这么一天，那么就来一起好好写一份简历吧。期间在网上找了不少写简历的资源，比如&lt;a href=&quot;https://qdan.me/list/VUR-PAX01x8Skk0F&quot;&gt;轻单-在线简历制作&lt;/a&gt;收录了一些在线生成简历的网站，有需要的童鞋可以直接拿走，不用再看这节课啦。&lt;br /&gt;
怎么可能！我对自己写的简历模板有信心，放这个出来就是要比比看。比比性价比，我们这个模版的价格是 0，分母是 0 就意味着性价比无穷大！写这个模版的初衷是希望同一份简历既能做页面展示，也能直接打印出来给我到处投。（请认真对待每一份简历，不要学习笔者）。写这份模版也是站在巨人的肩膀上，参考了前人经验的。感谢以下先辈：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/DIYgod/Resume&quot;&gt;一看 star 数就知道一定是最牛的简历&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.freepik.com/free-psd/editable-cv-format-download_716578.htm&quot;&gt;freepik 上的好看简历&lt;/a&gt;
&lt;br /&gt;我们可以利用 Github 的静态页面托管服务 Github Pages 来帮助我们做页面展示。
&lt;img src=&quot;https://raw.githubusercontent.com/caojiele/resume/master/img-folder/bd-show0.png&quot; alt=&quot;背景图&quot; /&gt;
&lt;strong&gt;什么是 Github Pages？&lt;/strong&gt;&lt;br /&gt;
Github Pages 是 Github 的静态页面托管服务。它设计的初衷是为了用户能够直接通过 Github 仓库来托管用户个人、组织或是项目的专属页面。参考：https://help.github.com/articles/what-is-github-pages/
可以说相当于一个可直接用 git 管理内容的静态服务器，有许多人会用它来托管自己的个人博客（利用 Jekyll、Pelican 这一类静态页面生成工具）或是在这上面发布自己的 HTML5 小游戏。当然这么好的东西也是有限制的。
&lt;br /&gt;&lt;strong&gt;Github Pages 的限制：&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;仓库存储的所有文件不能超过 1 GB。&lt;/li&gt;
  &lt;li&gt;页面的带宽限制是低于每月 100 GB 或是每月 100,000 次请求。&lt;/li&gt;
  &lt;li&gt;每小时最多只能部署 10 个静态网站。&lt;br /&gt;
对于发布自己的简历或是部署自己的博客的这一类需求我想是不用担心这些限制的，如果真的不小心超了，Github 那边不会采取什么强制措施，而是会发一份邮件提醒你应该找一个更适合你的托管对象的服务。
    &lt;h3 id=&quot;预备知识&quot;&gt;预备知识&lt;/h3&gt;
    &lt;p&gt;本项目需要的预备知识：
git 的基本使用
如果对 git 完全陌生，推荐学习实验楼的&lt;a href=&quot;https://www.shiyanlou.com/courses/4&quot;&gt;《Git 实战教程》&lt;/a&gt;，仅需了解最基本的操作即可。&lt;/p&gt;
    &lt;h3 id=&quot;项目知识点&quot;&gt;项目知识点&lt;/h3&gt;
    &lt;p&gt;本项目完成过程中，我们将学习：在 Github Pages 上部署自己的简历&lt;/p&gt;
    &lt;h3 id=&quot;适合人群&quot;&gt;适合人群&lt;/h3&gt;
    &lt;p&gt;适合对于简历有要求的同学，本项目可以完美的让你对简历进行管理&lt;/p&gt;
    &lt;h3 id=&quot;最终效果&quot;&gt;最终效果&lt;/h3&gt;
    &lt;p&gt;简历页面展示： 
&lt;br /&gt;&lt;img src=&quot;https://raw.githubusercontent.com/caojiele/resume/master/img-folder/bd_show3.png&quot; alt=&quot;简历页面展示&quot; /&gt;
保存后的 pdf 版本：
&lt;br /&gt;&lt;img src=&quot;https://raw.githubusercontent.com/caojiele/resume/master/img-folder/bd_show4.png&quot; alt=&quot;保存后的 pdf 版本&quot; /&gt; 
Mark简历生成器操作图：
&lt;br /&gt;&lt;img src=&quot;https://raw.githubusercontent.com/caojiele/resume/master/img-folder/Dynamic_figure2.gif&quot; alt=&quot;Mark简历生成器操作图&quot; /&gt;
&lt;br /&gt;网页链接：&lt;a href=&quot;http://caojiele.com/resume/&quot;&gt;Mark简历模板主页&lt;/a&gt;&lt;/p&gt;
    &lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
    &lt;p&gt;本课程主要是给没有接触过 Github Pages 的同学演示一遍它的基本使用，关于其它主题如自定义域名，自定义 404 页面等可在&lt;a href=&quot;https://help.github.com/categories/customizing-github-pages/&quot;&gt;Customizing GitHub Pages&lt;/a&gt;中找到参考。这里还需要再三提醒一句，千万不要在发布的简历中加上个人身份敏感信息呀！最后再给看到这里的同学一个福利吧：https://www.canva.com/templates/resumes/&lt;/p&gt;
    &lt;h3 id=&quot;关于作者&quot;&gt;关于作者&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;简书
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/u/faa01fa59ea3&quot;&gt;「小码哥个人主页」&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;知乎
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/people/wang-le-6-62/activities&quot;&gt;「小码哥个人主页」&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;segmentfault
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://segmentfault.com/u/xiaomage_5c10d17d26987&quot;&gt;「小码哥个人主页」&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;微信公众号  &lt;br /&gt;
 &lt;img src=&quot;https://raw.githubusercontent.com/caojiele/resume/master/img-folder/qrcode.jpg&quot; alt=&quot;微信公众号&quot; /&gt;
    &lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://help.github.com/categories/github-pages-basics/&quot;&gt;GitHub Pages Basics&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://help.github.com/categories/customizing-github-pages/&quot;&gt;Customizing GitHub Pages&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://codepen.io/ashblue/pen/mCtuA&quot;&gt;HTML5 Editable Table&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/DIYgod/Resume&quot;&gt;一看 star 数就知道一定是最牛的简历&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.freepik.com/free-psd/editable-cv-format-download_716578.htm&quot;&gt;freepik 上的好看简历&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/d95443bfdf75&quot;&gt;如何在Github Pages上生成部署简历&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://note.youdao.com/share/?id=a097d9dedfc367e44e8a5840bc250a96&amp;amp;type=note#/&quot;&gt;写简历注意事项&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 07 Dec 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/Jlcaoblog-boilerplate/2018/12/07/make-your-resume/</link>
        <guid isPermaLink="true">http://localhost:4000/Jlcaoblog-boilerplate/2018/12/07/make-your-resume/</guid>
        
        <category>Github Pages</category>
        
        <category>简历</category>
        
        
      </item>
    
      <item>
        <title>真正理解Mysql的四种事务隔离级别</title>
        <description>&lt;h3 id=&quot;什么是事务&quot;&gt;&lt;strong&gt;什么是事务&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。&lt;/p&gt;

&lt;p&gt;事务的结束有两种，当事务中的所以步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消撤消之前到事务开始时的所以操作。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;事务的 ACID&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability）。这四个特性简称为 ACID 特性。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;原子性：事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一致性：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;隔离性。一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。&lt;/li&gt;
  &lt;li&gt;持续性。也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Mysql的四种隔离级别&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Read Uncommitted（读取未提交内容）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Read Committed（读取提交内容）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Repeatable Read（可重读）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Serializable（可串行化）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。&lt;/p&gt;

&lt;p&gt;这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。例如：&lt;/p&gt;

&lt;p&gt;脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。&lt;/p&gt;

&lt;p&gt;不可重复读(Non-repeatable read)：在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。&lt;/p&gt;

&lt;p&gt;幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。&lt;/p&gt;

&lt;p&gt;在MySQL中，实现了这四种隔离级别，分别有可能产生问题如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-569e54f12a1edf4a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;测试mysql的隔离级别&quot;&gt;&lt;strong&gt;测试Mysql的隔离级别&lt;/strong&gt;&lt;/h3&gt;

&lt;p&gt;下面，将利用MySQL的客户端程序，我们分别来测试一下这几种隔离级别。&lt;/p&gt;

&lt;p&gt;测试数据库为demo，表为test；表结构：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-baf5617e74333630?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;两个命令行客户端分别为A，B；不断改变A的隔离级别，在B端修改数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（一）、将A的隔离级别设置为read uncommitted(未提交读)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-395ff493be112c17?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A：启动事务，此时数据为初始状态&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-314eabcddaec137f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;B：启动事务，更新数据，但不提交&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-3a20776e2b6bc93c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A：再次读取数据，发现数据已经被修改了，这就是所谓的“脏读”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-7b06bd13beb83519?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;B：回滚事务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-5677c85f96467cbe?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A：再次读数据，发现数据变回初始状态&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-d3c9d567815d3de0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;经过上面的实验可以得出结论，事务B更新了一条记录，但是没有提交，此时事务A可以查询出未提交记录。造成脏读现象。未提交读是最低的隔离级别。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;（二）、将客户端A的事务隔离级别设置为read committed(已提交读)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-c3e6091f1a2e3852?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A：启动事务，此时数据为初始状态&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-14304b43d327ef25?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;B：启动事务，更新数据，但不提交&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-79742468da1544b7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A：再次读数据，发现数据未被修改&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-0acda3f4c2fc1c8b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;B：提交事务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-53cdbd020c97b591?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A：再次读取数据，发现数据已发生变化，说明B提交的修改被事务中的A读到了，这就是所谓的“不可重复读”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-9816682a9994220d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;经过上面的实验可以得出结论，已提交读隔离级别解决了脏读的问题，但是出现了不可重复读的问题，即事务A在两次查询的数据不一致，因为在两次查询之间事务B更新了一条数据。已提交读只允许读取已提交的记录，但不要求可重复读。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(三)、将A的隔离级别设置为repeatable read(可重复读)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-2f33fb3c33595266?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A：启动事务，此时数据为初始状态&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-aac812c9c69167e5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;B：启动事务，更新数据，但不提交&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-1c39a730013fa813?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A：再次读取数据，发现数据未被修改&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-f312c27b945bb2a7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;B：提交事务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-b77ca148dfd11921?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A：再次读取数据，发现数据依然未发生变化，这说明这次可以重复读了&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-f8c3381d6193f422?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;B：插入一条新的数据，并提交&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-b5b13f58ae6347b7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A：再次读取数据，发现数据依然未发生变化，虽然可以重复读了，但是却发现读的不是最新数据，这就是所谓的“幻读”&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-4bc8286e491e31d1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A：提交本次事务，再次读取数据，发现读取正常了&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-cc9a3a86cb2aa3a1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;由以上的实验可以得出结论，可重复读隔离级别只允许读取已提交记录，而且在一个事务两次读取一个记录期间，其他事务部的更新该记录。但该事务不要求与其他事务可串行化。例如，当一个事务可以找到由一个已提交事务更新的记录，但是可能产生幻读问题(注意是可能，因为数据库对隔离级别的实现有所差别)。像以上的实验，就没有出现数据幻读的问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(四)、将A的隔离级别设置为可串行化(Serializable)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-1782e92173a07ee1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A：启动事务，此时数据为初始状态&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-7dc61aeb419483c9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;B：发现B此时进入了等待状态，原因是因为A的事务尚未提交，只能等待（此时，B可能会发生等待超时）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-3f9b50d71c489b62?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A：提交事务&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-9ac68445eef92398?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;B：发现插入成功&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-2cb357088fcdbc1b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;serializable完全锁定字段，若一个事务来查询同一份数据就必须等待，直到前一个事务完成并解除锁定为止。是完整的隔离级别，会锁定对应的数据表格，因而会有效率的问题。&lt;/p&gt;
</description>
        <pubDate>Mon, 09 Apr 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/Jlcaoblog-boilerplate/2018/04/09/mysql-transaction-isolation-level/</link>
        <guid isPermaLink="true">http://localhost:4000/Jlcaoblog-boilerplate/2018/04/09/mysql-transaction-isolation-level/</guid>
        
        <category>数据库</category>
        
        <category>Mysql</category>
        
        <category>事务隔离级别</category>
        
        
      </item>
    
      <item>
        <title>如何在私网环境实现异地SSH远程管理</title>
        <description>&lt;p&gt;由于不少中小型公司的宽带网络是没有固定IP的私网环境，同时还由于预算有限，因此通过传统方式很难建立VPN（&lt;code class=&quot;highlighter-rouge&quot;&gt;Virtual Private Network&lt;/code&gt;），对于IT运维人员而言异地SSH远程管理、维护就成了相当头疼的问题。&lt;/p&gt;

&lt;p&gt;不过面对此类问题，终于找到了解决方案。在使用花生壳中的蒲公英异地组网后，就可以轻松实现异地SSH远程管理，而且支持纯软件组网，即使在没有预算的情况下同样可以解决难题。&lt;/p&gt;

&lt;h3 id=&quot;1-linux中安装并配置蒲公英&quot;&gt;1. Linux中安装并配置蒲公英&lt;/h3&gt;

&lt;h4 id=&quot;1-1-预先准备&quot;&gt;1-1. 预先准备&lt;/h4&gt;

&lt;p&gt;服务器系统：&lt;code class=&quot;highlighter-rouge&quot;&gt;Centos 7.2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;所需软件：Linux版蒲公英VPN&lt;/p&gt;

&lt;p&gt;下载地址：http://pgy.oray.com/download/&lt;/p&gt;

&lt;p&gt;蒲公英Linux版除了拥有支持Centos、Redhat的安装包外，官网还提供了Ubuntu安装包。我们可以预先下载完成上传至服务器，也可直接进行下载。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-1098da0577d488e0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先，我先将已经将蒲公英安装包预先上传至了服务器（路径：&lt;code class=&quot;highlighter-rouge&quot;&gt;/home/jlcao/oray/PgyVPN_CentOS_2.0.1_x86_64.rpm&lt;/code&gt;）。理论上，只要是蒲公英官方支持的Linux发行版，就不必再安装环境，一键安装即可（32位需下载32位安装包，64位需下载64位安装包）。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-374b3705e200763f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我通过内网的一台Windows主机，使用Xshell5软件远程登录服务器，登录后使用su root命令获取了管理员权限，否则软件无法安装。&lt;/p&gt;

&lt;h4 id=&quot;1-2-安装软件&quot;&gt;1-2. 安装软件&lt;/h4&gt;

&lt;p&gt;通过cd命令进入存放蒲公英安装软件的目录，输入rpm命令进行安装；&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cd /home/jlcao/oray&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rpm -ivh PgyVPN_CentOS_2.0.1_x86_64.rpm&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-dbf4f59b4637f888?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;刚刚已经装过了，所以package已经存在。&lt;/p&gt;

&lt;h4 id=&quot;1-3-设置软件&quot;&gt;1-3. 设置软件&lt;/h4&gt;

&lt;p&gt;安装成功后，任意路径下输入“PgyVistor”命令即可调出交互界面，按照界面指示输入Oray账号或VPN ID进行登录，可以选择打开自动登录。如果没有账号可以在Oray官网（www.oray.com）注册即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-3f399ee0c362ec22?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;账号密码登陆一次后，直接记忆保存，下次直接登陆。&lt;/p&gt;

&lt;p&gt;登录成功后，输入对应的序号即可进入菜单，由于还未进行组网，因此获取组成员信息后，只能看到一个成员。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-7038a0dad7ee56c9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;到了这一步，Linux服务器端的设置已经完成。只要让蒲公英在后台运行即可，输入0后返回主界面，再输入9退出界面，让其在后台继续运行。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-e34527a91fd81e91?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-添加成员实现异地组网&quot;&gt;2. 添加成员，实现异地组网&lt;/h3&gt;

&lt;p&gt; 打开www.oray.com，用刚才注册或是已有的Oray账号登录，进入蒲公英-智能组网一栏创建网络，并点击管理，添加成员。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-780db91d55fddd1b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-90294dbf2ba066b6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;为了便于异地组网，除了将已有的客户端成员加入外，也可手动添加组网成员；&lt;/p&gt;

&lt;p&gt;蒲公英组网成员分为客户端成员与路由器成员；&lt;/p&gt;

&lt;p&gt; 路由器成员，则需输入蒲公英路由器的SN码进行添加；&lt;/p&gt;

&lt;p&gt;客户端成员，则需设置添加的数量及登录的密码，确认后生成VPN ID，可用于登录蒲公英客户端，这样一来，我们就不需要将Oray账号告诉其他人。&lt;/p&gt;

&lt;p&gt;最后，点击完成即可完成异地组网。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-90c7e6df92b09e1d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-699006ab6d630efc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;值得注意的是，成员列表一栏中可以对所有的已有成员进行管理，可对客户端成员进行绑定手机、修改登录密码及重置的操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-b45ae2cc4daadc35?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-51ba3875cfb4638f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-ssh远程管理测试&quot;&gt;3. SSH远程管理测试&lt;/h3&gt;

&lt;h4 id=&quot;3-1桌面端以windows为例&quot;&gt;3-1 桌面端，以Windows为例&lt;/h4&gt;

&lt;p&gt;安装蒲公英Windows版，通过已有VPN ID或是Oray账号登录。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-9e8234e794cbd157?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;蒲公英VPN win安装包&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-77c9a8abd1793746?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;登录后可以看到已有成员，右键可以ping主机，测试是否联通。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-26773b0f42f53041?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在Xshell 5 中键入蒲公英软件成员列表中显示的ip进行登录，现在即使在外网环境也可一样访问到公司里的服务器，进行远程维护。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-5020b6b5dd1a73c9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-2移动端以ios为例&quot;&gt;3-2 移动端，以IOS为例&lt;/h4&gt;

&lt;p&gt;在手机中安装蒲公英软件，同样通过通过已有VPN ID或是Oray账号登录。登录后可以看到已有成员，Linux服务器已在其中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-1c099f7c939848ea?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-28c00d80c3e1d5a1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;使用JuiceSSH等软件，键入蒲公英软件成员列表中显示的ip即可进行登录！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-a78bcff2bd24a6df?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;3-3配合蒲公英路由器&quot;&gt;3-3 配合蒲公英路由器&lt;/h4&gt;

&lt;p&gt;如果在成员中添加有蒲公英路由器，凡是接入蒲公英路由器的主机可以像局域网环境一样直接SSH远程管理成员中的主机。&lt;/p&gt;

&lt;h3 id=&quot;4-总结&quot;&gt;4. 总结：&lt;/h3&gt;

&lt;p&gt;以上采用蒲公英实现异地组网的方式，可以轻松解决私网环境无法通过SSH远程管理Linux服务器的问题，而且安装、配置过程相当简单，就算没有专业知识也能搞定。值得一提的是，蒲公英还拥有手机端管理App，即使出门在外也可对蒲公英VPN进行管理。&lt;/p&gt;

&lt;p&gt;不过，上述方式也存在一定的局限性，如果纯软件组网，可能无法满足多对多的情况，同时有多台服务器、多个运维需要异地SSH远程管理就可能无法很好的满足；而且蒲公英VPN软件要一直后台运行着并且登陆正常，才能正常工作；免费版本最多只能添加5个客户端（服务器+PC端+移动端就已经占了三个），可以满足个人的工作需求，但是此版本不符合企业级别，需要账号升级。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/6039661-90df7c3ccc9439a7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这时就要加入蒲公英路由器，通过路由器来异地组网，满足多个运维访问多台服务器的需求。&lt;/p&gt;
</description>
        <pubDate>Fri, 30 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/Jlcaoblog-boilerplate/2018/03/30/ssh-remote-management/</link>
        <guid isPermaLink="true">http://localhost:4000/Jlcaoblog-boilerplate/2018/03/30/ssh-remote-management/</guid>
        
        <category>Linux</category>
        
        <category>SSH</category>
        
        <category>VPN</category>
        
        
      </item>
    
      <item>
        <title>JavaScript 模块化七日谈</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;下滑这里查看更多内容&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;7月9日，我在公司内部进行了名为「JavaScript 模块化七日谈」分享，并将该 Slides 分享到了微博上。出乎意料地，这篇微博先后被 @JS小组 @尤小右 @寸志 等近 200 人转发，阅读达到 10w，获得了还不错的评价。&lt;/p&gt;

&lt;p&gt;于是，我决定将它重新发到我的博客上，并为它专门制作了适用于 Keynote 展示文稿的新布局。它能自动根据屏幕大小/旋转以一定比例填充屏幕，你也可以直接点击下方链接在新页面打开，来获得更好的、沉浸式的全屏体验。&lt;/p&gt;

&lt;h3 id=&quot;watch-fullscreen-&quot;&gt;&lt;a href=&quot;https://www.caojiele.com/js-module-7day/&quot;&gt;Watch Fullscreen →&lt;/a&gt;&lt;/h3&gt;

&lt;div class=&quot;visible-md visible-lg&quot;&gt;
&lt;img src=&quot;https://www.caojiele.com/js-module-7day/attach/qrcode.png&quot; width=&quot;350&quot; /&gt;&lt;br /&gt;
&lt;small class=&quot;img-hint&quot;&gt;你也可以通过扫描二维码在手机上观看&lt;/small&gt;
&lt;/div&gt;

&lt;p&gt;这个 Web Slides 开源在&lt;a href=&quot;https://github.com/caojiele/js-module-7day&quot;&gt;我的 Github 上&lt;/a&gt;，欢迎你帮助我完善这个展示文稿，你可以给我提 issue，可以 fork &amp;amp; pull request。如果它能帮助到你了，希望你还能不吝啬 star 一下这个项目。&lt;/p&gt;

&lt;h3 id=&quot;catalog&quot;&gt;Catalog&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;第一日 上古时期 &lt;strong&gt;&lt;em&gt;Module?&lt;/em&gt;&lt;/strong&gt; 从设计模式说起&lt;/li&gt;
  &lt;li&gt;第二日 石器时代 &lt;strong&gt;&lt;em&gt;Script Loader&lt;/em&gt;&lt;/strong&gt; 只有封装性可不够，我们还需要加载&lt;/li&gt;
  &lt;li&gt;第三日 蒸汽朋克 &lt;strong&gt;&lt;em&gt;Module Loader&lt;/em&gt;&lt;/strong&gt; 模块化架构的工业革命&lt;/li&gt;
  &lt;li&gt;第四日 号角吹响 &lt;strong&gt;&lt;em&gt;CommonJS&lt;/em&gt;&lt;/strong&gt; 征服世界的第一步是跳出浏览器&lt;/li&gt;
  &lt;li&gt;第五日 双塔奇兵 &lt;strong&gt;&lt;em&gt;AMD/CMD&lt;/em&gt;&lt;/strong&gt; 浏览器环境模块化方案&lt;/li&gt;
  &lt;li&gt;第六日 精灵宝钻 &lt;strong&gt;&lt;em&gt;Browserify/Webpack&lt;/em&gt;&lt;/strong&gt; 大势所趋，去掉这层包裹！&lt;/li&gt;
  &lt;li&gt;第七日 王者归来 &lt;strong&gt;&lt;em&gt;ES6 Module&lt;/em&gt;&lt;/strong&gt; 最后的战役&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;thanks&quot;&gt;Thanks&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://lab.hakim.se/reveal-js&quot;&gt;Reveal.js&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Jul 2015 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/Jlcaoblog-boilerplate/2015/07/09/js-module-7day/</link>
        <guid isPermaLink="true">http://localhost:4000/Jlcaoblog-boilerplate/2015/07/09/js-module-7day/</guid>
        
        <category>Slides</category>
        
        <category>Web</category>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>Welcome to Jlcao Blog</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“Yeah It’s on. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;caojiele 的 Blog 就这么开通了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#build&quot;&gt;跳过废话，直接看技术实现 &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2015 年，caojiele 总算有个地方可以好好写点东西了。&lt;/p&gt;

&lt;p&gt;作为一个程序员， Blog 这种轮子要是挂在大众博客程序上就太没意思了。一是觉得大部分 Blog 服务都太丑，二是觉得不能随便定制不好玩。之前因为太懒没有折腾，结果就一直连个写 Blog 的地儿都没有。&lt;/p&gt;

&lt;p&gt;在玩了一段时间知乎之后，答题的快感又激起了我开博客的冲动。之前的个人网站是作品集形式的（现在集成进来了），并不适合用来写博文，一不做二不休，花一天搞一个吧！&lt;/p&gt;

&lt;p id=&quot;build&quot;&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;

&lt;p&gt;接下来说说搭建这个博客的技术细节。&lt;/p&gt;

&lt;p&gt;正好之前就有关注过 &lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt; + &lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt; 快速 Building Blog 的技术方案，非常轻松时尚。&lt;/p&gt;

&lt;p&gt;其优点非常明显：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Markdown&lt;/strong&gt; 带来的优雅写作体验&lt;/li&gt;
  &lt;li&gt;非常熟悉的 Git workflow ，&lt;strong&gt;Git Commit 即 Blog Post&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;利用 GitHub Pages 的域名和免费无限空间，不用自己折腾主机
    &lt;ul&gt;
      &lt;li&gt;如果需要自定义域名，也只需要简单改改 DNS 加个 CNAME 就好了&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Jekyll 的自定制非常容易，基本就是个模版引擎&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本来觉得最大的缺点可能是 GitHub 在国内访问起来太慢，所以第二天一起床就到 GitCafe(Chinese GitHub Copy) 迁移了一个&lt;a href=&quot;http://caojiele.gitcafe.io&quot;&gt;镜像&lt;/a&gt;出来，结果还是巨慢。&lt;/p&gt;

&lt;p&gt;哥哥可是个前端好嘛！ 果断开 Chrome DevTool 查了下网络请求，原来是 &lt;strong&gt;pending 在了 Google Fonts&lt;/strong&gt; 上，页面渲染一直被阻塞到请求超时为止，难怪这么慢。&lt;br /&gt;
忍痛割爱，只好把 Web Fonts 去了（反正超时看到的也只能是 fallback ），果然一下就正常了，而且 GitHub 和 GitCafe 对比并没有感受到明显的速度差异，虽然 github 的 ping 值明显要高一些，达到了 300ms，于是用 DNSPOD 优化了一下速度。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;配置的过程中也没遇到什么坑，基本就是 Git 的流程，相当顺手&lt;/p&gt;

&lt;p&gt;大的 Jekyll 主题上直接 fork 了 Clean Blog（这个主题也相当有名，就不多赘述了。唯一的缺点大概就是没有标签支持，于是我给它补上了。）&lt;/p&gt;

&lt;p&gt;本地调试环境需要 &lt;code class=&quot;highlighter-rouge&quot;&gt;gem install jekyll&lt;/code&gt;，结果 rubygem 的源居然被墙了……后来手动改成了我大淘宝的镜像源才成功&lt;/p&gt;

&lt;p&gt;Theme 的 CSS 是基于 Bootstrap 定制的，看得不爽的地方直接在 Less 里改就好了（平时更习惯 SCSS 些），&lt;strong&gt;不过其实我一直觉得 Bootstrap 在移动端的体验做得相当一般，比我在淘宝参与的团队 CSS 框架差多了……&lt;/strong&gt;所以为了体验，也补了不少 CSS 进去&lt;/p&gt;

&lt;p&gt;最后就进入了耗时反而最长的&lt;strong&gt;做图、写字&lt;/strong&gt;阶段，也算是进入了&lt;strong&gt;写博客&lt;/strong&gt;的正轨，因为是类似 Hack Day 的方式去搭这个站的，所以折腾折腾着大半夜就过去了。&lt;/p&gt;

&lt;p&gt;第二天考虑中文字体的渲染，fork 了 &lt;a href=&quot;http://www.typeisbeautiful.com/&quot;&gt;Type is Beautiful&lt;/a&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;font&lt;/code&gt; CSS，调整了字号，适配了 Win 的渣渲染，中英文混排效果好多了。&lt;/p&gt;

&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;回顾这个博客的诞生，纯粹是出于个人兴趣。在知乎相关问题上回答并获得一定的 star 后，我决定把这个博客主题当作一个小小的开源项目来维护。&lt;/p&gt;

&lt;p&gt;在经历 v1.0 - v1.5 的蜕变后，这个博客主题愈发完整，不但增加了诸多 UI 层的优化（opinionated）；在代码层面，更加丰富的配置项也使得这个主题拥有了更好的灵活性与可拓展性。而作为一个开源项目，我也积极的为其完善文档与解决 issue。&lt;/p&gt;

&lt;p&gt;如果你恰好逛到了这里，希望你也能喜欢这个博客主题。&lt;/p&gt;

&lt;p&gt;—— caojiele 后记于 2015.10&lt;/p&gt;
</description>
        <pubDate>Thu, 29 Jan 2015 20:00:00 +0800</pubDate>
        <link>http://localhost:4000/Jlcaoblog-boilerplate/2015/01/29/hello-2015/</link>
        <guid isPermaLink="true">http://localhost:4000/Jlcaoblog-boilerplate/2015/01/29/hello-2015/</guid>
        
        <category>生活</category>
        
        
      </item>
    
  </channel>
</rss>
