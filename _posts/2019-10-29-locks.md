---
layout:     post
title:      "各种锁介绍"
subtitle:   "乐观锁/悲观锁、可重入锁"
date:       2019-10-29
author:     "Zark"
header-img: "img/in-post/2016.03/07/post-markdown-introduce.jpg"
tags:
    - 锁
---

## 主要内容
- [乐观锁/悲观锁](#乐观锁/悲观锁)  
- [可重入锁](#可重入锁)  
- [CAS](#CAS)  
- [公平锁/非公平锁](#公平锁/非公平锁)  
- [分段锁](#分段锁)

## 正文

### 乐观锁/悲观锁
#### 乐观锁：
乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。  
**适用于多读的应用类型，这样可以提高吞吐量**  
**cas其实就是乐观锁**

#### 悲观锁：
悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。  
**synchronized关键字其实就是悲观锁** 

### 可重入锁 
可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。（再次上锁是通过维护一个计数器state变量记录锁的次数）  
**ReentrantLock 和synchronized 都是 可重入锁**  
**可重入锁最大的作用是避免死锁**

### CAS
#### CAS概述：
比较和交换（Conmpare And Swap）是用于实现多线程同步的原子指令。 它将内存位置的内容与给定值进行比较，只有在相同的情况下，将该内存位置的内容修改为新的给定值。 这是作为单个原子操作完成的。  
**CAS可以有效的提升并发的效率**

#### ABA问题：
线程1从内存X中取出A，这时候另一个线程2也从内存X中取出A，并且线程2进行了一些操作将内存X中的值变成了B，然后线程2又将内存X中的数据变成A，这时候线程1进行CAS操作发现内存X中仍然是A，然后线程1操作成功。虽然线程1的CAS操作成功，但是整个过程就是有问题的。比如链表的头在变化了两次后恢复了原值，但是不代表链表就没有变化
JAVA中提供了AtomicStampedReference/AtomicMarkableReference来处理会发生ABA问题的场景，主要是在对象中额外再增加一个标记来标识对象是否有过变更
#### 自旋等待CPU开销大：
在高并发的情况下，线程1 cas 总是失败（compare值不相等），会一直重新计算新的值


### 公平锁/非公平锁  
#### 公平锁：
公平锁是指多个线程按照申请锁的顺序来获取锁
#### 非公平锁
非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。非公平锁的优点在于吞吐量比公平锁大  
**ReentrantLock 通过构造函数指定该锁是否是公平锁，默认是非公平锁**

### 分段锁  
#### 概述
ConcurrentHashMap 锁的设计。ConcurrentHashMap所使用的锁分段技术，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问

#### ConcurrentHashMap size计算
在 JDK1.7 中，他会先使用不加锁的模式去尝试多次计算 ConcurrentHashMap 的 size，最多三次，比较前后两次计算的结果，结果一致就认为当前没有元素加入，计算的结果是准确的。如果不符合，他就会给每个 Segment 加上锁，然后计算 ConcurrentHashMap 的 size 返回  
在 JDK1.8中， size 是通过对 baseCount 和 counterCell 进行 CAS 计算，最终通过 baseCount 和 遍历 CounterCell 数组得出 size。JDK 8 推荐使用mappingCount 方法，因为这个方法的返回值是 long 类型，不会因为 size 方法是 int 类型限制最大值。

### 偏向锁/轻量级锁/重量级锁  
### 自旋锁  
### 独享锁/共享锁  
### 互斥锁/读写锁  


尽管Java1.6为Synchronized做了优化，增加了从偏向锁到轻量级锁再到重量级锁的过度，但是在最终转变为重量级锁之后，性能仍然较低。
jdk1.6以后 对synchronized锁做了哪些优化

1.适应自旋锁

   自旋锁：为了减少线程状态改变带来的消耗 不停地执行当前线程 

2.锁消除：

  不可能存在共享数据竞争的锁进行消除

3.锁粗化：

  将连续的加锁 精简到只加一次锁

4.轻量级锁：

 无竞争条件下 通过CAS消除同步互斥

5.偏向锁：

无竞争条件下 消除整个同步互斥，连CAS都不操作。